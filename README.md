# ltx 裸机调度器

目录：

- [ltx 裸机调度器](#ltx-裸机调度器)
  - [一、项目简介](#一项目简介)
  - [二、基础组件](#二基础组件)
    - [1、定时器：](#1定时器)
    - [2、闹钟：](#2闹钟)
    - [3、发布订阅机制](#3发布订阅机制)
  - [三、拓展组件](#三拓展组件)
    - [1、app/应用](#1app应用)
    - [2、debug/调试](#2debug调试)
    - [3、script/脚本](#3script脚本)
    - [4、lock/锁](#4lock锁)
    - [5、event\_group/事件组](#5event_group事件组)
  - [四、移植](#四移植)
  - [五、其他](#五其他)

## 一、项目简介

这是一个轻量级的裸机调度器，目前仅在几个个人项目中使用，具体如下：

* [我的世界红石_数字方案](https://oshwhub.com/realtix/minecraft_redstone_digital)
* [反应力测试器](https://oshwhub.com/realtix/human_benchmark)
* [我的世界米家拉杆](https://oshwhub.com/realtix/lever)
* [唱片机](https://oshwhub.com/realtix/cover_display)

## 二、基础组件

### 1、定时器：

软件定时器，会按照周期定时发布一个话题，所有订阅者回调均会在此时被依次运行

### 2、闹钟：

闹钟组件常用于某些事件的超时检查，最初设计用于中断按键消抖，例如某个按键中断发生后立即创建一个 20ms 后的闹钟，每次抖动都会将闹钟倒计时重置为 20ms，直到不抖动 20ms 后闹钟到时调用回调，通过设置标志位，可区分第一次边沿变化与后续抖动，提高中断按键的响应速度以及提供更优雅的消抖方案，例如 [反应力测试器项目](https://gitee.com/TiX233/reaction_tester) 可提供仅 1us 延迟的中断按键功能

### 3、发布订阅机制

发布订阅机制常用于数据采样，例如定时器设置一个 20ms 一次的发起 adc dma 采样的任务，那么在 dma 采样完成回调里发布数据更新话题即可让所有订阅者获取最新的数据，无需所有数据使用者均创建一个 20ms 的定时器任务来 poll 数据，并且通过订阅与取消订阅，可方便地对数据打印进行开关。定时器任务也是通过发布话题通知订阅者实现的，所以可以实现对某些定时器任务进行 hook 操作

## 三、拓展组件

ltx 提供的 `app`、`脚本`、`事件组` 等等额外拓展功能组件皆由上述三个基础组件组合而来。  

### 1、app/应用

通过对软件定时器的封装，抽象出周期任务 task 以及隔离各业务的 app。

app 与 task 都有四个运行状态变更接口，分别为 `初始化`、`暂停`、`继续` 以及 `销毁`。

例如可以将采集传感器的内容放在一个 app 内，创建多个 task 来定期采集数据，那么外部就可以较为分明地对其进行启停。在 `ltx_cmd.c` 中有一个可供用户调试 app 的 `ltx_app` 命令，通过这个命令，可以用串口来打印所有 app 及其 task，并对其进行启停操作，便于调试

### 2、debug/调试

内含两个部分，分别为 `ltx_cmd.c` 和 `ltx_param.c`，前者用于创建一些串口调试命令，后者用于创建一些可供串口修改的系统参数。

通过自定义命令，可控制单片机的运行状态，比如暂停某些 app 等，也可依赖发布订阅机制实现数据更新后的自动打印，在 `ltx_cmd.c` 中提供的 `/print` 命令有一个 `heart_beat` 样例，用来每秒打印心跳，您可参考该样例来设置自己的订阅数据打印；  
如果您需要经常修改一些参数如尝试某些不同的背景颜色，那么也无需重新烧录，在 `ltx_cmd.c` 中提供了一个 `/param` 命令，该命令可更改 `ltx_param.c` 中指向的自定义数据进行读写；

所有的自定义命令可在 `ltx_cmd.c` 中查看，也可开机后给单片机发送 `/help` 命令来列出所有命令，您也可以参考这些命令创建一些方便调试自定义命令。

### 3、script/脚本

脚本组件原设计用于执行特定的序列如显示屏初始化这种需要多次发送数据的固定步骤场景，  
现已丰富为类似状态机协程的存在，配合 ltx 调度器，可实现步骤间非阻塞延时以及新步骤非阻塞等待话题发布并设置等待超时时间，  
大部分场景可取代 app 组件提供的 task 这一定时轮询任务功能，  
通过设置步骤间延时为 0 tick，可实现仅出让单次调度轮询，而非出让一整个时间片（1 ms）

### 4、lock/锁

用于对某些资源进行上锁操作，例如 spi 正在 dma 刷屏，则可在刷屏前上锁，在发送完成回调中解锁。  
锁有超时机制，当锁超时后，会调用用户自定义超时回调，用户可以在这里解锁资源与锁，例如强制停止 dma 发送。  
锁在解锁时会发布一个话题。

锁机制对于裸机意义不大，但是可以作为一个能保存标志位的 topic  
未来将会为脚本增加一个等待锁解锁的功能

### 5、event_group/事件组

可设置等待超时时间以及 31 个等待的事件，设计用于等待所有硬件初始化完成，使用一个 uint32 的整数来存储所有事件，最高位用于判断事件组回调是否为超时所调用

## 四、移植

如果仅需要基础组件，那么只需要移植 `ltx.c` 和 `ltx.h` 即可。

因为是裸机调度器，所以移植几乎没有难度，最快仅需两步即可：

1、系统嘀嗒

在 1ms 周期的 systick 中断中调用如下函数：

```c
ltx_Sys_tick_tack();
```

2、在 main.c 最后调用如下函数：


```c
ltx_Sys_schedule_start();
ltx_Sys_scheduler();
```

3、例如：

```c
#include "main.h"
#include "ltx.h"
// #include "myAPP_system.h"
// #include "myAPP_device_init.h"

// ...

int main(void){
    // 初始化外设
    // ...

    // 创建组件
    // ...

    /* 如果想拥有更强的业务隔离与管理能力，那么还可以额外引入 ltx_app 组件
    // 创建 app
    // 系统调试 app
    ltx_App_init(&app_system); // 初始化 app
    ltx_App_resume(&app_system); // 运行 app

    // 硬件初始化 app
    ltx_App_init(&app_device_init); // 初始化 app
    ltx_App_resume(&app_device_init); // 运行 app
    */

    // 开启调度
    ltx_Sys_schedule_start();
    // 运行调度器
    ltx_Sys_scheduler(); // 调度器内部有一个无限循环，所以后续代码不会被运行

    while(1);
}

// ...

// systick 中断服务函数
void SysTick_Handler(void)
{
    HAL_IncTick();

    // 添加系统嘀嗒
    ltx_Sys_tick_tack();
}

```

## 五、其他

对于链表，暂时不是原子操作，**可能会在嵌套中断时产生意想不到的问题**，目前理论上只有 topic publish 能安全地在中断中使用，其余如添加移除闹钟等等链表操作可能存在风险，后续可能改进相关内容  
如果目前有中断中增删组件需求，可专门创建一个话题，在中断中发布话题，让话题订阅者回调（linux 线程化中断下半部说是）操作组件
